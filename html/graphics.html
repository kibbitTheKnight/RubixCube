<!DOCTYPE html>
<html>
	<head>
	<title>Final Project: Rubix Cube Solver</title>
	<script src="https://threejs.org/build/three.js"></script>
	<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
	<script>
	function eulerRotation(cube,command,angle)
	{
		// get the rotation sign and calculate the rotation
        const rotInRads = (command[1] === 1 ? angle : -angle);
		// let rotation = new THREE.Euler();
        let axis = [0, 0, 0];
        let rotation = new THREE.Matrix4();

        //get the correct axis from the input
		switch(command[0])
		{
		    // rotate about the y-axis
			case 1 :
			case 2 :
			case 3 :
				{
					axis[0] = 1;
					break;
				}
			// rotate about the x-axis
			case 4 :
			case 5 :
			case 6 :
				{
					axis[1] = 1;
					break;
				}
			//rotate about the z-axis
            case 7 :
            case 8 :
            case 9 :
                {
				axis[2] = 1;
                break;
            	}
			default:
				console.log("invalid command");
				return
		}

		// this is how the slices are encoded, there slight perturbation in the coordinate values so that must be accounted for when creating the logic.
		// 1 : +y
		// 2 : y == 0
		// 3 : -y
		// 4 : -x
		// 5 : x == 0
		// 6 : +x
		// 7 : -z
		// 8 : z == 0
		// 9 : +z
		switch (axis.indexOf(1))
		{
		    // rotation about the y-axis by 90 degrees
			case 0:
			{
				yaxis = new THREE.Vector3(0,1,0);
				cube.forEach(function(e){
					pos = e.position;
					if (command[0] === 1) //slice is above the origin
					{
						if (pos.y > 1) // is positive
						{
							rotation.makeRotationAxis(yaxis.normalize(),rotInRads); // create the rotation
							e.applyMatrix(rotation); // apply the rotation.
						}
					}
					else if (command[0] === 2) // slice is on the origin
					{
						// todo: implement this but don't need it yet.
					}
					else //slice is below the origin
					{
						if (pos.y < -1) // is negative
						{
						    rotation.makeRotationAxis(yaxis.normalize(),rotInRads);
						    e.applyMatrix(rotation);
						}
					}
				});

                break;
			}
			// rotation about the x-axis by 90 degrees
			case 1:
			{
			    xaxis = new THREE.Vector3(1,0,0);
			    cube.forEach(function(e){
                    pos = e.position;
                    if (command[0] === 4) //slice is left of origin
                    {
                        if (pos.x < -1)
                        {
                            rotation.makeRotationAxis(xaxis.normalize(),rotInRads);
                            e.applyMatrix(rotation);
                        }
                    }
                    else if (command[0] === 5) // slice is on the origin
                    {
                        // todo: implement this but don't need it yet.
                    }
                    else //slice is right of origin
                    {
                        if (pos.x > 1)
                        {
                            rotation.makeRotationAxis(xaxis.normalize(),rotInRads);
                            e.applyMatrix(rotation);
                        }
                    }
				});
			    break;
			}
			// rotation about the z-axis by 90 degrees
			case 2:
			{
			    zaxis = new THREE.Vector3(0,0,1);
			    cube.forEach(function(e){
			        pos = e.position;
			        if (command[0] === 7)
					{
						if(pos.z < -1) //slice is -z from the origin
						{
						    rotation.makeRotationAxis(zaxis.normalize(),rotInRads);
						    e.applyMatrix(rotation);
						}
					}
					else if(command[0] === 8) //slice is on the origin
					{
					    //todo: implement this but don't need it yet.
					}
					else // slice is +z relative to the origin
					{
			            if(pos.z > 1)
						{
						    rotation.makeRotationAxis(zaxis.normalize(),rotInRads);
						    e.applyMatrix(rotation);
						}
					}
				});
			    break;
			}
			default:
			    console.log("invalid axis!!!!");
			    return;
		}
	}

	function createCubes(scene, materials)
	{
		cubes = [];
		for (let x = 0; x < 3; x++)
		{
			for (let y = 0; y < 3; y++)
			{
				for (let z = 0; z < 3; z++)
				{
					let faceMaterial = new THREE.MeshFaceMaterial(materials);
					let cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
					let cube = new THREE.Mesh(cubeGeometry, faceMaterial);
					let position = 1.05;
					cube.position.x = (x - 1) * position;
					cube.position.y = (y - 1) * position;
					cube.position.z = (z - 1) * position;
					cubes.push(cube);
				}
			}
		}

		for(i = 0; i < cubes.length; i++)
		{
			scene.add(cubes[i]);
		}

		return cubes;
	}

	function showAxis(scene)
	{
		let xMaterial = new THREE.LineBasicMaterial({color: 0x2f55cf, linewidth: 2}); //green
		let yMaterial = new THREE.LineBasicMaterial({color: 0xff7800, linewidth: 2}); //red
		let zMaterial = new THREE.LineBasicMaterial({color: 0x26b143, linewidth: 2}); //blue

		let xGeo = new THREE.Geometry();
		xGeo.vertices.push(new THREE.Vector3(0,0,0));
		xGeo.vertices.push(new THREE.Vector3(10,0,0));
		xGeo.vertices.push(new THREE.Vector3(-10,0,0));

		let yGeo = new THREE.Geometry();
		yGeo.vertices.push(new THREE.Vector3(0,0,0));
		yGeo.vertices.push(new THREE.Vector3(0,10,0));
		yGeo.vertices.push(new THREE.Vector3(0,-10,0));

		let zGeo = new THREE.Geometry();
		zGeo.vertices.push(new THREE.Vector3(0,0,0));
		zGeo.vertices.push(new THREE.Vector3(0,0,10));
		zGeo.vertices.push(new THREE.Vector3(0,0,-10));

		xline = new THREE.Line(xGeo, xMaterial);
		yline = new THREE.Line(yGeo, yMaterial);
		zline = new THREE.Line(zGeo, zMaterial);

		scene.add(xline);
		scene.add(yline);
		scene.add(zline);
	}
	</script>
	
	<script>
		function mainFunction()
		{
			//create renderer
			let renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight);
			document.body.appendChild( renderer.domElement);
			renderer.setClearColor (0x8dc8e0, 1);
			
			//create scene and camera
			let scene = new THREE.Scene();
			let aspect = window.innerWidth/window.innerHeight;
			let camera = new THREE.PerspectiveCamera( 75, aspect, 0.1, 100 );
			camera.position.z= 6;
			scene.add(camera);
			
			//lights
			let keyLight = new THREE.DirectionalLight(0xFFBF80, 1.0);
			keyLight.position.set(-0.5, 0.5, 1);
			let fillLight = new THREE.DirectionalLight(0x8080FF, 1.5);
			fillLight.position.set(1, 0, 1);
			let backLight = new THREE.DirectionalLight(0xffffff, 0.5);
			backLight.position.set(0.5, -0.5, -1).normalize();
			let ambientLight = new THREE.AmbientLight( 0x404040 );

			scene.add(keyLight);
			scene.add(fillLight);
			scene.add(backLight);
			scene.add(ambientLight);

			// uncomment this to show xyz coordinate axis.
			// showAxis(scene);
			
			//create cubes
			let materials = 
			[
				new THREE.MeshBasicMaterial({color: 0xd92b2c}), // orange
				new THREE.MeshBasicMaterial({color: 0xff7800}), // red
				new THREE.MeshBasicMaterial({color: 0xffffff}), // white
				new THREE.MeshBasicMaterial({color: 0xe6e621}), // yellow
				new THREE.MeshBasicMaterial({color: 0x26b143}), // blue
				new THREE.MeshBasicMaterial({color: 0x2f55cf}), // green
			];

			let cube = createCubes(scene, materials);

			// this holds all of the commands that are to be executed
            let commandQueue = [];
			// this holds the angles to be executed
            let angleQueue = [];

            // some sample commands
			commandQueue.push([1,1]);
			commandQueue.push([6,-1]);
			commandQueue.push([7,1]);
            commandQueue.push([9,-1]);
            commandQueue.push([3,1]);
            commandQueue.push([1,-1]);

			// these are offsets for the number of frames it will take to complete a 90 degree rotation, not sure why they are not both exactly 60, but it works.
            let xz = 61;
            let y = 57;
            let myAngle = 0;
            let applyingAngle = false;
            let currentCommand = [];

			//animation function
			function render()
			{
				requestAnimationFrame(render);
				renderer.render( scene, camera );
                // eulerRotation(cube,[1,1],myAngle);
				if (!applyingAngle)
				{
                    if (commandQueue.length !== 0)
                    {
                        currentCommand = commandQueue.shift();
                        if (currentCommand[0] === 1 || currentCommand[0] === 2 || currentCommand[0] === 3)
                        {
                            myAngle = (Math.PI / 2) / y;
                            for (let i = 0;i < y;++i) { angleQueue.push(myAngle);}
                        }
                        else
						{
                            myAngle = (Math.PI / 2) / xz;
                            for (let i = 0;i < xz;++i) { angleQueue.push(myAngle);}
                        }
                    }
                    applyingAngle = true;
                }
				else
				{
					if(angleQueue.length > 0)
					{
                        eulerRotation(cube,currentCommand,angleQueue.shift());
					}
					else
					{
					    currentCommand = [];
					    applyingAngle = false;
					}
				}
			}
				
			//controls
			let cameraControl= new THREE.OrbitControls( camera );
			render();
		}
		</script>
	</head>
	<body onload="mainFunction();">
		<h1 style="font-family:verdana;"> Keira Taylor and Ashley Smith</h1>
	</body>
</html>