<!DOCTYPE html>
<html>
	<head>
	<title>Final Project: Rubix Cube Solver</title>
	<script src="https://threejs.org/build/three.js"></script>
	<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
	<script src="../js/solver.js"</script></script>
	<script>
	function eulerRotation(cube,command,angle)
	{
		// get the rotation sign and calculate the rotation
        const rotInRads = (command[1] === 1 ? angle : -angle);
		// var rotation = new THREE.Euler();
		var axis = [0, 0, 0];
		var designator = 0;

		switch(command[0])
		{
		    // rotate about the y-axis
			case 1 :
				{
					axis[0] = 1;
					designator = 1; // all y values are positive
					break;
				}
			case 2 :
				{
					axis[0] = 1;
					designator = 0; // all y values are 0
					break;
				}
			case 3 :
				{
					axis[0] = 1;
					designator = -1; // all y values are negative
					break;
				}
			// rotate about the x-axis
			case 4 :
				{
					axis[1] = 1;
					designator = -1; // all x values are negative
					break;
				}
			case 5 :
				{
					axis[1] = 1;
					designator = 0; // all x values are 0
					break;
				}
			case 6 :
				{
					axis[1] = 1;
					designator = 1; // all x values are positive
					break;
				}
			//rotate about the z-axis
            case 7 :
				{
					designator = -1; // all z values are negative
					axis[2] = 1;
					break;
				}
            case 8 :
				{
					axis[2] = 1;
					designator = 0; // all z values are 0
					break;
				}
            case 9 :
                {
				axis[2] = 1;
				designator = 1; // all z values are positive
                break;
            	}
			default:
				console.log("invalid command");
				return
		}

		switch (axis.indexOf(1))
		{
		    // rotation about the y-axis by 90 degrees
			case 0:
			{
				yaxis = new THREE.Vector3(0,1,0);
                rotation = new THREE.Matrix4();
				cube.forEach(function(e){
					pos = e.position;
					if (command[0] === 1) //slice is above the origin
					{
						if (pos.y > 0) // is positive
						{
							rotation.makeRotationAxis(yaxis.normalize(),rotInRads); // create the rotation
							e.applyMatrix(rotation); // apply the rotation.
						}
					}
					else if (command[0] === 2) // slice is on the origin
					{
						// todo: implement this but don't readily need it yet.
					}
					else //slice is below the origin
					{
						if (pos.y < 0) // is negative
						{
							e.rotateOnWorldAxis(yaxis,rotInRads);
						}
					}
				});

                break;
			}
			// rotation about the x-axis by 90 degrees
			case 1:
			{
			    xaxis = new THREE.Vector3(1,0,0);
			    cube.forEach(function(e){
                    pos = e.position;
                    if (command[0] === 4) //slice is left of origin
                    {
                        if (pos.x < 0) // is positive
                        {
                            e.rotateOnWorldAxis(xaxis,rotInRads);
                        }
                    }
                    else if (command[0] === 5) // slice is on the origin
                    {
                        // todo: implement this but don't readily need it yet.
                    }
                    else //slice is right of origin
                    {
                        if (pos.x > 0) // is negative
                        {
                            e.rotateOnWorldAxis(xaxis,rotInRads);
                        }
                    }
				});
			    break;
			}
			// rotation about the z-axis by 90 degrees
			case 2:
			{
			    break;
			}
			default:
			    console.log("invalid axis!!!!");
			    return;
		}
	}

	function rotateAroundWorldAxis(object, axis, radians)
	{
        rotWorldMatrix = new THREE.Matrix4();
        rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
        rotWorldMatrix.multiplySelf(object.matrix);        // pre-multiply
        object.matrix = rotWorldMatrix;
        object.rotation.getRotationFromMatrix(object.matrix, object.scale);
	}


	function rotateCube(face, cube, axis, scene, r, cc)
		{
			var turns = [];
			turns.push(new Array(6));
			//console.log(cube);
			turns[4] = [8, 17, 26, 5, 14, 23, 2, 11, 20]; //front, green face
			turns[5] = [24, 15, 6, 21, 12, 3, 18, 9, 0]; //back, blue face
			turns[0] = [6, 7, 8, 3, 4, 5, 0, 1, 2]; //left, orange face
			turns[1] = [26, 25 ,24, 23, 22, 21, 20, 19, 18]; //right, red face
			turns[2] = [24, 25, 26, 15, 16, 17, 6, 7, 8]; //up, white face
			turns[3] = [0, 1, 2, 9, 10, 11, 18, 19, 20]; //down, yellow face
			/*var list = new THREE.Object3D();
			for(i = 0; i < cube.length; i++)
			{
				scene.remove(cube[i]);
			}
			for(i = 0; i < 9; i++)
			{
				//cube[turns[face][i]].rotateOnAxis(axis, cc * r);
				/*cube[turns[face][i]].position.x += axis.x;
				cube[turns[face][i]].position.y += axis.y;
				cube[turns[face][i]].position.z += axis.z;
				cube[turns[face][i]].rotation.x += (cc * r);
				list.add(cube[turns[face][i]]);
				console.log(cube[turns[face][i]]);
			}
			list.rotateOnAxis(axis, cc * r);
			list.rotation.x = (cc * r);
			for(i = 0; i < 9; i++)
			{
				list.remove(cube[turns[face][i]]);
			}
			for(i = 0; i < cube.length; i++)
			{
				scene.add(cube[i]);
			}*/
			for(i = 0; i < cube.length; i++)
			{
				scene.remove(cube[i]);
			}
			var list = new THREE.Group();
			for(i = 0; i < 9; i++)
			{
				list.add(cube[turns[face][i]]);
				cube.splice(turns[face][i], 1);
			}
			console.log(list);
			for(i = 0; i < 9; i++)
			{
				list.rotateOnWorldAxis(axis, cc * r);
				cube.splice(turns[face][i], 0, list.children[i]);
				//list.remove(cube[turns[face][i]]);
			}
			for(i = 0; i < cube.length; i++)
			{
				scene.add(cube[i]);
			}
			//scene.add(list);
			
		
		}
		function createCubes(scene, materials) 
		{

			var cubes = [];
			var edges = [];
			for (var x = 0; x < 3; x++) 
			{
				for (var y = 0; y < 3; y++) 
				{
					for (var z = 0; z < 3; z++) 
					{
						var faceMaterial = new THREE.MeshFaceMaterial(materials);
						var cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
						var cube = new THREE.Mesh(cubeGeometry, faceMaterial);
						var position = 1.05;
						cube.position.x = (x - 1) * position;
						cube.position.y = (y - 1) * position;
						cube.position.z = (z - 1) * position;
						
						var edge = new THREE.EdgesGeometry( cubeGeometry );
						var line = new THREE.LineSegments( edge, new THREE.LineBasicMaterial( { color: 0x000000, linewidth: 1 } ) );
						line.position.x = (x - 1) * position;
						line.position.y = (y - 1) * position;
						line.position.z = (z - 1) * position;
						
						cubes.push(cube);
						edges.push(line);
					}
				}
			}
			
			for(i = 0; i < cubes.length; i++)
			{
				scene.add(cubes[i]);
				scene.add(edges[i]);
			}
			
			return cubes;
		}

		function showAxis(scene)
		{
		    var xMaterial = new THREE.LineBasicMaterial({color: 0x2f55cf, linewidth: 2}); //green
            var yMaterial = new THREE.LineBasicMaterial({color: 0xff7800, linewidth: 2}); //red
            var zMaterial = new THREE.LineBasicMaterial({color: 0x26b143, linewidth: 2}); //blue

			var xGeo = new THREE.Geometry();
			xGeo.vertices.push(new THREE.Vector3(0,0,0));
            xGeo.vertices.push(new THREE.Vector3(10,0,0));
            xGeo.vertices.push(new THREE.Vector3(-10,0,0));

            var yGeo = new THREE.Geometry();
            yGeo.vertices.push(new THREE.Vector3(0,0,0));
            yGeo.vertices.push(new THREE.Vector3(0,10,0));
            yGeo.vertices.push(new THREE.Vector3(0,-10,0));

            var zGeo = new THREE.Geometry();
            zGeo.vertices.push(new THREE.Vector3(0,0,0));
            zGeo.vertices.push(new THREE.Vector3(0,0,10));
            zGeo.vertices.push(new THREE.Vector3(0,0,-10));

            xline = new THREE.Line(xGeo, xMaterial);
            yline = new THREE.Line(yGeo, yMaterial);
            zline = new THREE.Line(zGeo, zMaterial);

            scene.add(xline);
            scene.add(yline);
            scene.add(zline);
		}
	</script>zGeo
	
	<script>
		function mainFunction()
		{
			//create renderer
			let renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight);
			document.body.appendChild( renderer.domElement);
			renderer.setClearColor (0x8dc8e0, 1);
			
			//create scene and camera
			let scene = new THREE.Scene();
			let aspect = window.innerWidth/window.innerHeight;
			let camera = new THREE.PerspectiveCamera( 75, aspect, 0.1, 100 );
			camera.position.z= 6;
			scene.add(camera);
			
			//lights
			let keyLight = new THREE.DirectionalLight(0xFFBF80, 1.0);
			keyLight.position.set(-0.5, 0.5, 1);
			let fillLight = new THREE.DirectionalLight(0x8080FF, 1.5);
			fillLight.position.set(1, 0, 1);
			let backLight = new THREE.DirectionalLight(0xffffff, 0.5);
			backLight.position.set(0.5, -0.5, -1).normalize();
			var ambientLight = new THREE.AmbientLight( 0x404040 );
			scene.add(keyLight);
			scene.add(fillLight);
			scene.add(backLight);
			scene.add(ambientLight);
			
			//define axes

            var axis = [];
            axis.push(new Array(6));

            axis[0] = new THREE.Vector3(1, 0, 0);
            axis[1] = new THREE.Vector3(-1, 0, 0);
            axis[2] = new THREE.Vector3(0, 1, 0);
            axis[3] = new THREE.Vector3(0, -1, 0);
            axis[4] = new THREE.Vector3(0, 0, 1);
            axis[5] = new THREE.Vector3(0, 0, -1);
			showAxis(scene);
			
			//create cubes
			var materials = 
			[
				new THREE.MeshBasicMaterial({color: 0xd92b2c}), // orange
				new THREE.MeshBasicMaterial({color: 0xff7800}), // red
				new THREE.MeshBasicMaterial({color: 0xffffff}), // white
				new THREE.MeshBasicMaterial({color: 0xe6e621}), // yellow
				new THREE.MeshBasicMaterial({color: 0x26b143}), // blue
				new THREE.MeshBasicMaterial({color: 0x2f55cf}), // green
			];
			var cube = createCubes(scene, materials);
			
			var jsCube = createJSCube();


			var rotate = false;
			counter = 0;
			myAngle = (Math.PI/2)/60;
			//animation function
			function render()
			{
				requestAnimationFrame(render);
				renderer.render( scene, camera );
                eulerRotation(cube,[1,1],myAngle);
				// if(counter <= 60)
				// {
                 //    eulerRotation(cube,[1,1],myAngle);
                 //    counter++;
				// }

			}
				
			//controls
			let cameraControl= new THREE.OrbitControls( camera );
			render();
		}
		</script>
	</head>
	<body onload="mainFunction();">
		<h1 style="font-family:verdana;"> Keira Taylor and Ashley Smith</h1>
	</body>
</html>